#include "Database.h"
#include "HelperFunctions.h"

Database GD::db;

Database::Database()
{
	if(mysql_library_init(0, NULL, NULL))
	{
		HelperFunctions::printCritical("Could not initialize MySQL library.");
		return;
	}
}

void Database::init()
{
	if(!mysql_thread_safe())
	{
		HelperFunctions::printCritical("MySQL client library is not compiled thread safe.");
		return;
	}
}

Database::~Database()
{
    uint32_t i = 0;
	while(_threadCounter > 0 && i < 150)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
		i++;
	}
    mysql_library_end();
}

bool Database::working()
{
	MYSQL* mysql = connect();
	if(mysql)
	{
		close(mysql);
		mysql_thread_end();
		return true;
	}
	mysql_thread_end();
	return false;
}

MYSQL* Database::connect()
{
	try
	{
		MYSQL* mysql = mysql_init(nullptr);
		if(!mysql)
		{
			HelperFunctions::printCritical("Could not initialize MySQL object (Error no.: " + std::to_string(mysql_errno(mysql)) + "): " + mysql_error(mysql));
			return nullptr;
		}
		if(!mysql_real_connect(mysql, GD::settings.mySQLServer().c_str(), GD::settings.mySQLUser().c_str(), GD::settings.mySQLPassword().c_str(), GD::settings.mySQLDatabase().c_str(), 0, NULL, 0))
		{
			HelperFunctions::printCritical("Could not connect to MySQL database (Error no.: " + std::to_string(mysql_errno(mysql)) + "): " + mysql_error(mysql));
			close(mysql);
			return nullptr;
		}
		return mysql;
	}
	catch(const std::exception& ex)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
    return nullptr;
}

void Database::close(MYSQL* mysql)
{
	try
	{
		if(mysql) mysql_close(mysql);
	}
	catch(const std::exception& ex)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
    	HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
}

void Database::getDataRows(MYSQL_STMT* statement, DataTable& dataRows)
{
	try
	{
		uint32_t row = 0;
		while(true)
		{
			MYSQL_RES* mysqlResult = mysql_stmt_result_metadata(statement);
			if(!mysqlResult)
			{
				int32_t errorNumber = mysql_stmt_errno(statement);
				if(errorNumber == 0) return; //No meta information
				HelperFunctions::printError("Error calling mysql_stmt_result_metadata (Error no.: " + std::to_string(errorNumber) + "): " + mysql_stmt_error(statement));
				return;
			}

			//Returns no errors
			int32_t fieldCount = mysql_stmt_field_count(statement);
			if(fieldCount == 0)
			{
				mysql_free_result(mysqlResult);
				return;
			}

			//Returns no errors
			MYSQL_FIELD* fields = mysql_fetch_fields(mysqlResult);

			MYSQL_BIND mysqlBind[fieldCount];
			memset(mysqlBind, 0, sizeof(MYSQL_BIND) * fieldCount);

			for(uint32_t i = 0; i < fieldCount; i++)
			{
				std::shared_ptr<DataColumn> col(new DataColumn());
				col->index = i;
				if(fields[i].type == MYSQL_TYPE_LONGLONG)
				{
					col->dataType = DataColumn::DataType::Enum::INTEGER;
					mysqlBind[i].buffer = (char*)&col->intValue;
					mysqlBind[i].buffer_length = 8;
				}
				else if(fields[i].type == MYSQL_TYPE_DOUBLE)
				{
					col->dataType = DataColumn::DataType::Enum::DOUBLE;
					mysqlBind[i].buffer = (char*)&col->doubleValue;
					mysqlBind[i].buffer_length = 8;
				}
				else if(fields[i].type == MYSQL_TYPE_BLOB)
				{
					col->dataType = DataColumn::DataType::Enum::BLOB;
					col->binaryValue->resize(fields[i].length);
					mysqlBind[i].buffer = &col->binaryValue->at(0);
					mysqlBind[i].buffer_length = fields[i].length;
				}
				else if(fields[i].type == MYSQL_TYPE_STRING)
				{
					col->dataType = DataColumn::DataType::Enum::TEXT;
					col->textValue.resize(fields[i].length);
					mysqlBind[i].buffer = &col->textValue.at(0);
					mysqlBind[i].buffer_length = fields[i].length;
				}
				else if(fields[i].type == MYSQL_TYPE_NULL)
				{
					col->dataType = DataColumn::DataType::Enum::NODATA;
					mysqlBind[i].buffer = nullptr;
					mysqlBind[i].buffer_length = 0;
				}
				if(mysql_stmt_bind_result(statement, mysqlBind))
				{
					HelperFunctions::printError("Error binding result to statement (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
					return;
				}
				dataRows[row][i] = col;
			}
			int32_t ret = mysql_stmt_next_result(statement);
			mysql_free_result(mysqlResult);
			if(ret == -1) return; //No more results
			else if(ret > 0)
			{
				HelperFunctions::printError("Error getting next result (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
				return;
			}
			row++;
		}

	}
	catch(const std::exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
}

MYSQL_STMT* Database::createStatement(MYSQL* mysql, std::string& command, DataColumnVector& dataToEscape, MYSQL_BIND* bind)
{
	//Example: http://dev.mysql.com/doc/refman/5.5/en/mysql-stmt-execute.html
	MYSQL_STMT* statement;
	statement = mysql_stmt_init(mysql);
	if(!statement)
	{
		HelperFunctions::printError("Error calling mysql_stmt_init (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
		return nullptr;
	}

	mysql_stmt_prepare(statement, command.c_str(), command.size());

	if(dataToEscape.empty()) return statement;

	int32_t result;
	int32_t index = 0;
	std::for_each(dataToEscape.begin(), dataToEscape.end(), [&](std::shared_ptr<DataColumn> col)
	{
		switch(col->dataType)
		{
			case DataColumn::DataType::Enum::NODATA:
				bind[index].buffer_type = MYSQL_TYPE_NULL;
				bind[index].buffer = &col->intValue;
				bind[index].is_null = col->myBoolTrue();
				bind[index].length = 0;
				break;
			case DataColumn::DataType::Enum::INTEGER:
				bind[index].buffer_type = MYSQL_TYPE_LONGLONG;
				bind[index].buffer = &col->intValue;
				bind[index].is_null = 0;
				bind[index].length = 0;
				break;
			case DataColumn::DataType::Enum::DOUBLE:
				bind[index].buffer_type = MYSQL_TYPE_DOUBLE;
				bind[index].buffer = &col->doubleValue;
				bind[index].is_null = 0;
				bind[index].length = 0;
				break;
			case DataColumn::DataType::Enum::BLOB:
				if(col->binaryValue->empty())
				{
					bind[index].buffer_type = MYSQL_TYPE_NULL;
					bind[index].buffer = &col->intValue;
					bind[index].is_null = col->myBoolTrue();
					bind[index].length = 0;
				}
				else
				{
					bind[index].buffer_type = MYSQL_TYPE_BLOB;
					bind[index].buffer = &col->binaryValue->at(0);
					bind[index].buffer_length = col->binaryValue->size();
					bind[index].is_null = 0;
					bind[index].length = col->getLength();
				}
				break;
			case DataColumn::DataType::Enum::TEXT:
				bind[index].buffer_type = MYSQL_TYPE_STRING;
				bind[index].buffer = col->getCString();
				bind[index].buffer_length = col->textValue.size();
				bind[index].is_null = 0;
				bind[index].length = col->getLength();
				break;
		}
		index++;
	});
	if(mysql_stmt_bind_param(statement, bind))
	{
		HelperFunctions::printError("Error binding parameters to statement (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
		return nullptr;
	}
	return statement;
}

uint32_t Database::executeWriteCommand(std::string command, DataColumnVector& dataToEscape)
{
	try
    {
		std::cerr << command << std::endl;
		_databaseMutex.lock();
		MYSQL* mysql = connect();
		if(!mysql)
		{
			mysql_thread_end();
			_databaseMutex.unlock();
			return 0;
		}
		uint32_t id = 0;
		MYSQL_BIND bind[dataToEscape.size()];
		memset(bind, 0, sizeof(MYSQL_BIND) * dataToEscape.size());
		MYSQL_STMT* statement = createStatement(mysql, command, dataToEscape, &bind[0]);
		if(statement)
		{
			if(mysql_stmt_execute(statement)) HelperFunctions::printError("Error executing statement (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
			else id = mysql_stmt_insert_id(statement);
			mysql_stmt_close(statement);
		}

		mysql_thread_end();
		_databaseMutex.unlock();
		return id;
	}
    catch(const std::exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
    _databaseMutex.unlock();
	return 0;
}

DataTable Database::executeCommand(std::string command, DataColumnVector& dataToEscape)
{
	std::cerr << command << std::endl;
	DataTable dataRows;
	try
    {
		_databaseMutex.lock();
		MYSQL* mysql = connect();
		if(!mysql)
		{
			_databaseMutex.unlock();
			return dataRows;
		}
		MYSQL_BIND bind[dataToEscape.size()];
		memset(bind, 0, sizeof(MYSQL_BIND) * dataToEscape.size());
		MYSQL_STMT* statement = createStatement(mysql, command, dataToEscape, &bind[0]);
		if(statement)
		{
			if(mysql_stmt_execute(statement))
			{
				HelperFunctions::printError("Error executing statement (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
			}
			getDataRows(statement, dataRows);
			mysql_stmt_close(statement);
		}
		close(mysql);
		mysql_thread_end();
	}
    catch(const std::exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
    _databaseMutex.unlock();
	return dataRows;
}

DataTable Database::executeCommand(std::string command)
{
	try
    {
		DataColumnVector dataToEscape;
		return executeCommand(command, dataToEscape);
	}
    catch(const std::exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
    return DataTable();
}

void Database::executeWriteCommandAsync(std::string command, DataColumnVector& dataToEscape)
{
	try
    {
		std::cerr << command << std::endl;
		_threadCounter++;
		std::thread t(&Database::executeWriteCommandAsyncThread, this, command, dataToEscape);
		t.detach();
	}
    catch(const std::exception& ex)
    {
    	_threadCounter--;
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
    	_threadCounter--;
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
    	_threadCounter--;
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
}

void Database::executeWriteCommandAsyncThread(std::string command, DataColumnVector dataToEscape)
{
	try
    {
		_databaseMutex.lock();
		MYSQL* mysql = connect();
		if(!mysql)
		{
			_threadCounter--;
			mysql_thread_end();
			_databaseMutex.unlock();
			return;
		}
		MYSQL_BIND bind[dataToEscape.size()];
		memset(bind, 0, sizeof(MYSQL_BIND) * dataToEscape.size());
		MYSQL_STMT* statement = createStatement(mysql, command, dataToEscape, &bind[0]);
		if(statement)
		{
			if(mysql_stmt_execute(statement))
			{
				HelperFunctions::printError("Error executing statement (Error no.: " + std::to_string(mysql_stmt_errno(statement)) + "): " + mysql_stmt_error(statement));
			}
			mysql_stmt_close(statement);
		}
		mysql_thread_end();
	}
    catch(const std::exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(Exception& ex)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__, ex.what());
    }
    catch(...)
    {
        HelperFunctions::printEx(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
    _threadCounter--;
    _databaseMutex.unlock();
}
