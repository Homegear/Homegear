#ifndef DATABASE_H
#define DATABASE_H

#include <iostream>
#include <mutex>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <memory>
#include <mysql/mysql.h>

#include "Exception.h"
#include "GD.h"


class DataColumn
{
    public:
		struct DataType
		{
			enum Enum { NODATA, INTEGER, DOUBLE, TEXT, BLOB };
		};

        DataType::Enum dataType = DataType::Enum::NODATA;
        int32_t index = 0;
        int64_t intValue = 0;
        double doubleValue = 0;
        std::string textValue;
        std::shared_ptr<std::vector<char>> binaryValue;

        DataColumn() { binaryValue.reset(new std::vector<char>()); }
        DataColumn(int64_t value) : DataColumn() { dataType = DataType::Enum::INTEGER; intValue = value; }
        DataColumn(uint64_t value) : DataColumn() { dataType = DataType::Enum::INTEGER; intValue = value; }
        DataColumn(int32_t value) : DataColumn() { dataType = DataType::Enum::INTEGER; intValue = value; }
        DataColumn(uint32_t value) : DataColumn() { dataType = DataType::Enum::INTEGER; intValue = value; }
        DataColumn(std::string value) : DataColumn() { dataType = DataType::Enum::TEXT; textValue = value; }
        DataColumn(double value) : DataColumn() { dataType = DataType::Enum::DOUBLE; doubleValue = value; }
        DataColumn(std::shared_ptr<std::vector<char>> value) : DataColumn() { dataType = DataType::Enum::BLOB; if(value) binaryValue = value; }
        DataColumn(std::vector<char>& value) : DataColumn()
        {
        	dataType = DataType::Enum::BLOB;
        	binaryValue.reset(new std::vector<char>());
        	*binaryValue = value;
        }
        DataColumn(std::vector<uint8_t>& value) : DataColumn()
        {
        	dataType = DataType::Enum::BLOB;
        	binaryValue.reset(new std::vector<char>());
        	binaryValue->insert(binaryValue->begin(), value.begin(), value.end());
        }
        virtual ~DataColumn() {}
        long unsigned int* getLength() { return (long unsigned int*)&_length; }
        char* getCString()
        {
        	_cString.insert(_cString.begin(), textValue.begin(), textValue.end());
        	return &_cString.at(0);
        }
        char* myBoolTrue() { return &_myBoolTrue; }
    private:
        uint32_t _length = 0;
        std::vector<char> _cString;
        char _myBoolTrue = 1;
};

typedef std::map<uint32_t, std::map<uint32_t, std::shared_ptr<DataColumn>>> DataTable;
typedef std::vector<std::shared_ptr<DataColumn>> DataColumnVector;

class Database
{
    public:
		Database();
        virtual ~Database();
        void init();
        uint32_t executeWriteCommand(std::string command, DataColumnVector& dataToEscape);
        void executeWriteCommandAsync(std::string command, DataColumnVector& dataToEscape);
        DataTable executeCommand(std::string command, DataColumnVector& dataToEscape);
        DataTable executeCommand(std::string command);
        bool working();
    protected:
    private:
        int32_t _threadCounter = 0;
        std::mutex _databaseMutex;

        MYSQL* connect();
        void close(MYSQL* mysql);
        void getDataRows(MYSQL_STMT* statement, DataTable& dataRows);
        MYSQL_STMT* createStatement(MYSQL* mysql, std::string& command, DataColumnVector& dataToEscape, MYSQL_BIND* bind);
        void executeWriteCommandAsyncThread(std::string command, DataColumnVector dataToEscape);
};

#endif // DATABASE_H
